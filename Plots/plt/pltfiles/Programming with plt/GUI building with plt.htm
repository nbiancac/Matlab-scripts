<html>
<head>
<title>GUI building with plt</title>
<style>
<!--
span.mcode
{ color: #ff0000;
  font-family: 'Lucida Console', 'Andale Mono', 'Courier New', monospace;
  font-size: smaller;
}
span.mcode2
{ color: #ff0000;
  font-family: 'Lucida Console', 'Andale Mono', 'Courier New', monospace;
  font-size: 75% 
}
span.mcode3
{ color: #0000ff;
  font-family: 'Lucida Console', 'Andale Mono', 'Courier New', monospace;
  font-size: smaller;
}
span.cmt
{ color: #0000ff;
  font-size: smaller;
}
-->
</style>
</head>
<body>

<img src="../images/plt.png" width="300" height="160" align="right"></td>
<br><h1>GUI building with plt</h1> <br clear="left">
Over the years I have created dozens of GUIs using Matlab, nearly all of which
involved collecting and/or viewing data and interacting with the data or data collection
process in some way, and I suspect the same is true for the GUIs that you need to create.
The first GUIs I created were quite difficult, but as I built up my bag of tools each
new program became easier and quicker to write. The key I found was to avoid re-inventing
the wheel each time and the best way to do that was to create a series 
of "<font size="+1" color="0000ff">pseudo objects</font>". A pseudo object is a collection
of Matlab graphics objects embedded with features commonly needed in Matlab GUI applications.
(I chose to call them pseudo objects to distinguish them from the graphics objects supplied
in the standard Matlab environment.) These pseudo objects are combined into one file exchange
submission called (for historical reasons) <font color="0000ff">plt</font>. My primary goal for
plt is to make building GUI applications in Matlab easier, faster, and more fun while
enabling you to create clearer, more concise code that is compatible across all Matlab
platforms and versions.
<br><br>
The two main tasks in creating a GUI application are:
<ol>
<li>Choosing the graphical elements and configuring the sizes and positions of these elements.
<li>Writing the code that enables these graphical elements to serve their intended purpose.
</ol>

Matlab's GUI building tool (called <span class="mcode">Guide</span>) helps a lot with the first
task but contributes little to the second. However I've found that for all but the most trivial
applications, the second task accounts for most of the frustrations and time spent. My strategy
is to aid the second task by providing a rich set of the pseudo objects mentioned above.
It may seem like this is a tall order for these new objects, but I hope the examples that
follow will convince you that they can impressively reduce the amount of code you need to write.
The current set of pseudo objects is merely a start. I plan to continue implementing new
pseudo objects ... hopefully many of them conceived by Matlab users such as yourself.
<br><br>
A parallel goal is to make it easier to learn Matlab GUI programming by providing many well
commented examples that demonstrate as many of the pseudo object features as possible. It's
easier to begin a new GUI application by starting with an example that has at least some
of the graphical features that you need. To this end, plt includes 26 example programs
covering a wide variety of GUI features and programming techniques. New example programs
have been steadily added to the list over the years since the first version of plt, often
initiated by questions and requests sent to me by plt users.

Although the standard Matlab plotting and graphical elements are thoroughly documented, a
common complaint is that this information is spread out over thousands of pages of Matlab
documentation making it difficult to find what you are looking for. Also it is difficult
to find examples for most features. This inspired me to design the plt help file to
avoid these pitfalls by organizing plt's many features into one coherent help file including
many examples. Every question from a plt user leads me to reexamine the documentation
to see if I have described each feature and example as completely and clearly as possible.
<br><br>
Although the first task mentioned above (configuring sizes and positions of graphical elements)
is not where most of the time is spent, without an appropriate tool this could be a painstaking
task. Matlab's Guide tool does provide a reasonable solution to this problem however I found
several annoyances with this tool:
<ol>
<li>Guide forces me to adopt a particular programming methodology and style. Although plt
    offers unique pseudo objects you are free to use all or none of them to suit your purpose
    and no demands are made on your programming style. My preferences lean towards conciseness
    and clarity, as you can see from my programming examples.
<li>Guide has evolved over the years and works somewhat differently in different Matlab versions
    which can cause compatibility issues. I often support my Matlab applications for use with older
    Matlab versions, some of which were released even before Guide was invented.
<li>I sometimes find it inconvenient that the program definition is split between the
    .m and .fig files. The .fig file format can also lead to Matlab version dependencies.
    (GUIs designed with plt don't depend on .fig files.)
<li>And most importantly Guide was not compatible with the powerful pseudo objects that I had created.
</ol>

In addition, to the Guide compatibility issues mentioned in point 2 above, the graphics objects
themselves have changed between versions. For example the latest Matlab version (R2014b) finally
allows you to set the grid line color independently allowing you to create far more pleasing plots.
However this won't help when you try to run your program on previous Matlab versions (which in fact
represent the majority of the user base). On the other hand, plt is designed to work the same across
all Matlab versions, so you can share your code with colleagues running older Matlab versions.
I have tested plt on most Matlab releases dating as
far back as June 2001 (Matlab&nbsp;6.1) and of course it works with Matlab's most recent
R2014b version as well. You might think that supporting older versions would limit plt's flexibility,
however as you will see plt generally meets or exceeds the flexibility available with even the
latest native Matlab plot commands (including grid lines of course).
<br><br>
After abandoning Guide for the above reasons, at first I simply entered position coordinates
by hand, often iterating many times to adjust controls to achieve the desired look. But for
complicated GUIs with many objects, this is too time consuming. This led me to develop a more
automated method of positioning pseudo objects as well as native Matlab objects without using Guide.
This method is not quite as automated as Guide, but I hope you will see from the following
examples that it strikes a good balance between automation, power, and flexibility.

The basic idea was to give plt the the ability to reposition and resize the graphical objects
and to display the results in a way that allows you to copy the positions of all your
objects into your program with a single cut and paste. I demonstrate how easy
this is to do in this video:
<a href="http://www.mennen.org/plt/pltfiles/demoImages/MatlabGUIbuilding.mp4">MatlabGUIbuilding.mp4</a>.
Before viewing the video you may want to briefly familiarize yourself with the pseudo objects that
have been implemented so far:
<ul>
<li><font color="blue" size="+1"><b>Cursor - </b></font>My goal for the cursor pseudo object was to
    tailor plt for its role in data exploration. The ease and responsiveness of the cursoring,
    panning, and zooming operations is unmatched by any other Matlab plotting package (at
    least according to reports from some plt users). Although you can create cursor pseudo objects
    independently, by default a cursor object is created for you when you define a plt pseudo
    object. This relieves you of the need to know about the many details of the cursor object.
   <li><font color="blue" size="+1"><b>Grid - </b></font>In the latest Matlab release (R2014b) you
    can change the grid color using the axis 'gridcolor' property. However as I mentioned earlier,
    using this property will give an error if you run the program on any earlier Matlab release.
    If you are using any release earlier than R2014b, you can see the problem by typing
    <span class="mcode"><nobr>plot(rand(1,100)); grid&nbsp;on;</nobr></span>. and note how the
    grid lines are so overpowering it is hard to see the trace underneath. Now try changing
    the grid line color to something less overwhelming by typing
    <span class="mcode"><nobr>set(gca,'xcolor',[.7 .7 .7],'ycolor',[.7 .7 .7]);</nobr></span>.
    Now the grid lines look pretty nice but the tick labels become so faint you can barely see
    them. (This insanity was an annoyance and embarrassment to Matlab users for at least two
    decades and in fact was one of my motivations for creating the first version of plt a decade ago).
    The plt grid pseudo object gives you even more flexibility than the latest Matlab release by
    allowing you to select the grid color, thickness, line style, and erase mode without
    affecting any other graphic element. As with the cursor pseudo object, you will rarely need
    to define a grid pseudo object explicitly since it is also created by the plt pseudo object.
    The defaults are to most people's liking so you may never need to adjust them.
  <li><font color="blue" size="+1"><b>plt - </b></font>This can be thought of a super axis (or
    collection of axes). In that respect it is similar to Matlab's <span class="mcode">plot</span>
    and data is passed to plt in the same way making simple calls to plt look the same as
    the call to plot (except for the missing "o"). However unlike plot, plt also (by default
    anyway) creates:
    <ul>
    <li>a cursor pseudo object.
    <li>a grid pseudo object.
    <li>a menu box containing various plotting controls.
    <li>a TraceID box which serves both as a legend and as a way to enable
            and disable individual traces.
    <li>a menu bar containing the traditional Matlab menus (File,Edit,View,Tools,etc) as
        well as a plt menu containing items unique to plt.
    </ul>
    The plt pseudo object integrates all these elements together in a consistent
    logical manner with the defaults oriented towards the typical data exploration
    needs of the most common graphical interfaces. This allows you to take advantage
    of the plt features in your design even before learning about the many ways to
    tailor plt to your needs.
<li><font color="blue" size="+1"><b>Slider - </b></font>Matlab's slider is the most
    versatile uicontrol because of the many ways you can change the value (dragging
    the slider bar, clicking the left or right arrow, clicking the trough). Plus it
    is the only uicontrol whose action can repeat continuously as you hold down the
    mouse button. This allows you to smoothly vary a parameter over a range while
    observing its effect. However the slider control rarely can stand alone. At a
    minimum you need a label to identify what the control is for and usually you
    also need a more precise representation of the slider value than the slider bar
    itself provides. A text box is often used for this purpose, although an edit box
    is better since it allows a way to set the slider value precisely. It is also
    common to want labels to identify the minimum and maximum values associated with
    the left and right slider bar positions. Furthermore sometimes the slider value
    must be restricted to be an integer or a multiple of some other factor or other
    condition (such as a power of 2 for example). Also you may want to adjust the
    step size for the arrows or trough or to make the steps logarithmically spaced.
    These requirements mean that you usually need to write a lot of code to make
    a slider useful for your application. The pseudo slider solves this problem by
    integrating all the elements and options just mentioned into one object that you
    can simply drop into your application and move around as a unit. All the code you
    need to make it useful is already done for you!
<li><font color="blue" size="+1"><b>Edit - </b></font>As mentioned above, the ability
    of the slider and the pseudo slider to respond continuously as the mouse button
    is held down is a powerful feature. The one drawback of these objects is that they
    take up quite a bit of space. For a GUI with many controls, you may not have room to use
    sliders for many of them. The edit pseudo object is the answer to such a problem. It
    takes up even less space than a uicontrol edit box. It doesn't have all the features
    of the pseudo slider, but you can continuously increment its value by holding down
    the mouse on the right side of the object, and likewise decrement its value on the
    left side. Like the pseudo slider, you can select the increment amount as well as
    the min/max limits. The edit object may also be used to contain vectors or strings.
    (The auto-increment features do not apply in that case.) Usually edit objects require a
    label to identify the purpose of the control. The edit pseudo object includes a label
    (optionally) as an integrated feature. When you reposition the edit control, the label
    moves right along with it. One less graphical object to define, size, and position.
    Other advantages over the uicontrol edit box include:
    <ul>
    <li>Auto evaluations
    <li>More flexible formatting
    <li>More powerful callbacks
    <li>Tex interpreter support
    <li>Choice of figure or axis coordinates
    </ul>
    As an example of an Auto evaluation, consider that typing "cos(pi/6)" into the pseudo
    object would set its value to 0.866025 (with fewer or more digits depending on the format code).
    The last point also deserves elaboration. Normally you will want to define the edit pseudo
    object in figure coordinates (what I call a type I edit pseudo object) just as you do
    with a uicontrol. However if you want to associate the object with a plot (so it moves
    with the plot if it is repositioned, or if you want to create an array of edit objects
    it is more convenient to use axis coordinates (i.e. a type II edit pseudo object).
<li><font color="blue" size="+1"><b>Popup - </b></font>The popup pseudo object closely
    mimics the function of Matlab's popup uicontrol but has these advantages:
    <ul>
    <li>You can fit twice as many pseudo popups into a given space as uicontrol popups.
	<li>You can cycle through the popup's options without opening the popup by right
        clicking on the object. When you want to see the effect of all the possible
        selections, it is far faster with the pseudo popup than with the uicontrol.
    <li>Optionally swap the role of left & right clicks (super-button mode).
    <li>Integrated label (optional).
    <li>More powerful callbacks.
    <li>Independent control of the location/appearance of the opened and closed view of the popup.
    <li>More flexible formatting.
    <li>Tex interpreter support.
	<li>Ability to open or close the popup from a program.
    </ul>
    Of course uicontrol popups and uicontrol edit boxes may still be used and may be
    preferred when you don't need any of the advantages listed above.
<li><font color="blue" size="+1"><b>ColorPick - </b></font>Nothing is quite as individual
    as the colors we prefer in our applications, and allowing the user to choose the
    application colors is a true sign that the programmer cares about the user. However
    choosing several colors that have to blend together in a pleasing way is not a simple
    matter and providing a substandard interface for color choice can be more of a curse
    than a blessing. The ColorPick pseudo object was carefully designed to make it as
    easy as possible to give your application this flexibility. I've found it is important
    to present the user with palettes of colors to choose from and have the selected
    objects change instantly when a new choice is made. A very simple example of the use
    of the ColorPick object is given in gui2.m. A more elaborate example is the demoplt.m
    program which also includes the code to save the selected colors in a setup file
    so that the chosen colors remain permanent until changed again.
</ul>
A more complete description of these pseudo objects from a programming perspective
can be found here: <a href="Pseudo%20objects.htm">Pseudo objects</a>.
<br><br>
Now you are prepared to jump to the video. If the video moves too fast for you, or you
simply prefer reading to watching, the video script is shown below:

<h2>A first example</h2>

Our first GUI example doesn't do any plotting or anything else useful for that matter, so it may
not present a compelling case for the GUI tools provided by plt. However since it consists
of just a few dozen lines of code it is simple enough that you can quickly see how to use plt
to arrange graphic elements inside a figure window.
<br><br>
<img src="../images/gui1Sketch.png" align="left" width="400">
I find that it is best to start working on a new GUI with pencil and paper. Imagine
the control types and arrangement for the application and then sketch a mock up such as this.
Your finished application rarely will look much like your first sketch, but with the rapid
prototyping possible with Matlab and plt you can quickly iterate improvements in form,
concept and implementation.
<br><br>
Here I have decided on 3 pseudo sliders across the top followed below by a uitable on the left
and a frame on the right containing 4 uicontrols (a popup, slider, button, and checkbox).
<br><br>
The bottom part of the GUI consists of two large objects for displaying lists of numbers.
The right most one is a simple text box with room to show about 10 lines of text. The left most
one is a listbox which by virtue of its scroll bar can display a far larger data set
(80 lines of text in this example).
<br clear=left><br>
First we create the figure window. I usually start by typing "figure" in the command window
and adjust the figure size to get a first guess. In this example I decide on 430 by 350 pixels.
The menu bar is not needed for such a simple GUI so the menu property is set to 'none'.
I chose a dark blue-green for the figure background:
<br><br>
<nobr><span class="mcode">function gui1(in1) </span>&nbsp;</nobr><br>
<nobr><span class="mcode">&nbsp; figure('name','gui1','menu','none','pos',[60 60 430 350],'color',[0 .1 .2]);</span></nobr>
<br><br>
The next line defines the choices for the popup menu.
Then we create the array which contains the positions for the three pseudo sliders followed by a
single position which is (initially) used for all the uicontrols as well as the uitable.
Note that all three slider positions are exactly the same (in the middle of the figure).
This is easy and convenient at the moment, but means that all three sliders will appear on
top of each other. Not a problem however, as it will be easy to use the mouse to move and
resize the sliders to an appropriate position. We will use the fourth (and last) position
in this array for all the uicontrols. So of course all these controls will also appear on
top of each other, but again we will use the mouse to move them to the desired locations.
<br><br>
<nobr><span class="mcode">&nbsp; cho = {'choice A' 'choice B' 'choice C'}; &nbsp; &nbsp; &nbsp; &nbsp;</span>
      <span class="cmt">% choices for popup control</span></nobr>
<nobr><span class="mcode">&nbsp; p = {[.5 .5]; [.5 .5]; [.5 .5]; [.1 .1 .1 .1]}; &nbsp;</span>
      <span class="cmt">% initial positions: Slider1; Slider2; Slider3; All uicontrols</span></nobr>
<br><br>
Next, the three pseudo sliders and the uitable are created.
@CBsli, the last parameter of the slider call, specifies the callback - a function that will be called when the slider value is changed.
Note that we save the handles of these four objects even though we don't really use them. (In a real GUI we would almost always need them.)
<br><br>
<nobr><span class="mcode">&nbsp; h1 = plt('slider',p{1}, 10,'PseudoSlider 1',@CBsli); &nbsp;</span><span class="cmt">% create the pseudo sliders</span></nobr><br>
<nobr><span class="mcode">&nbsp; h2 = plt('slider',p{2}, 60,'PseudoSlider 2',@CBsli);</span>&nbsp;</nobr><br>
<nobr><span class="mcode">&nbsp; h3 = plt('slider',p{3},800,'PseudoSlider 3',@CBsli);</span>&nbsp;</nobr><br>
<nobr><span class="mcode">&nbsp; h4 = uitable('units','norm','pos',p{4});&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span>
         <span class="cmt">% create the uitable</span></nobr>
<br><br>

Since the uitable hadn't been invented yet for Matlab 6, there is an alternate version of gui1.m in
the demo folder called gui1v6.m where this uitable is replaced by a radio button. Of course these two
objects don't serve the same function, but since we aren't worried yet about functionality with this
example, this is not a problem.
<br><br>
Next, let's create all seven uicontrols in a single line while collecting the handles in a variable
named "h". (A long variable name I know ...) The spaces after the "h = " are there so that the property
values (style, string, and callback) in the following three lines line up under the respective uicontrol
command. This makes it easier to follow what is going on.
<br><br>
<nobr><span class="mcode">&nbsp; h = &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;[uicontrol uicontrol uicontrol uicontrol uicontrol uicontrol uicontrol];</span>&nbsp;</nobr><br> 
<nobr><span class="mcode">&nbsp; set(h,{'style'},{'frame' ;'popup'; &nbsp;'slider';'pushb' &nbsp;;'checkbox';'listbox';'text';},...;</span>&nbsp;</nobr><br>
<nobr><span class="mcode">&nbsp; &nbsp; &nbsp; &nbsp;{'string'},{'frame1'; cho &nbsp; ; &nbsp;'slider';'button1';'check001';'' &nbsp; &nbsp; &nbsp; ;'' &nbsp; &nbsp; },...;</span>&nbsp;</nobr><br>
<nobr><span class="mcode">&nbsp; &nbsp; &nbsp; &nbsp;{ 'callb'},{'' &nbsp; &nbsp; &nbsp;; @CBpop; &nbsp;@CBsli &nbsp;;@CBpush &nbsp;; @CBcheck ;'' &nbsp; &nbsp; &nbsp; ;'' &nbsp; &nbsp; },...;</span>&nbsp;</nobr><br>
<nobr><span class="mcode">&nbsp; &nbsp; &nbsp; &nbsp;'backgr',[.5 1 1],'units','norm','pos',p{4});;</span></nobr>
<br><br>
Finally we save all 11 handles  in the figure user data so the callbacks can easily find them (h1,h2,h3,h4
followed by the seven uicontrols we just created). This method works fine for such a simple program, but in
the next example we will see the advantages of using a structure for this purpose instead of an array.
We also execute the callback function to initialize the random data tables:
<br><br>
<nobr><span class="mcode">&nbsp; set(gcf,'user',[h1 h2 h3 h4 h]);  CBsli; </span><span class="cmt">% save the handles and execute the slider callback</span></nobr>
<br><br>
That's it for the main function, just 14 lines of code! (Although we will add a few more lines later.)
We finish up by writing the control callbacks.
The first three are just stubs to remind us to eventually put some useful action there.
The last one (the slider callback) is the only one that does anything, which is to update the data tables with new random data.
The reason the random numbers are in the exponent is to create numbers with a widely varying magnitude so that the table looks more interesting.
(The same random numbers get put into both the textbox and the listbox).
Note that the random numbers are converted to strings using "prin" a substitute for "sprintf" that includes features commonly needed in GUI
programming. (prin.m and its documentation prin.pdf are included with plt.)
<br><br>
<nobr><span class="mcode">function CBpop(a,b) &nbsp; </span><span class="cmt">% popup callback -------------</span></nobr><br>
<nobr><span class="mcode">&nbsp; disp('popup callback');</span>&nbsp;</nobr><br>
<nobr><span class="mcode">function CBcheck(a,b) </span><span class="cmt">% checkbox callback ---------</span></nobr><font size="+2">&nbsp;<br></font>
<nobr><span class="mcode">&nbsp; disp('checkbox callback');</span>&nbsp;</nobr><br>
<nobr><span class="mcode">function CBpush(a,b) &nbsp;</span><span class="cmt">% button callback -------------</span></nobr><font size="+2">&nbsp;<br></font>
<nobr><span class="mcode">&nbsp; disp('pushbutton callback');</span>&nbsp;</nobr><br>
<nobr><span class="mcode">function CBsli(a,b) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="cmt">% slider callback -----------------------------</span></nobr><font size="+2">&nbsp;<br></font>
<nobr><span class="mcode">&nbsp; h = get(gcf,'user'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span><span class="cmt">% get the object handles</span></nobr><br>
<nobr><span class="mcode">&nbsp; t = 1e20.^(rand(3,80))/1e6; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="cmt">% generate the random data</span></nobr><br>
<nobr><span class="mcode">&nbsp; set(h(10:11),'fontname','courier',... </span><span class="cmt">% convert random data to a cell array</span></nobr><br>
<nobr><span class="mcode">&nbsp; &nbsp; 'string',prin('3{%6V   }~, ',t)); &nbsp; &nbsp; </span><span class="cmt">% of strings for the listbox and the textbox</span></nobr><br>
<nobr><span class="mcode">&nbsp; set(h(4),'data',100*rand(3,2)); &nbsp; &nbsp; &nbsp; </span><span class="cmt">% more random data for the uitable</span></nobr><br>&nbsp;
<br><br>
<img src="../images/gui1Place1.png" width=238 height=207 hspace=10 vspace=10 align="left"><br>
Now that we are done with the coding, start the GUI by typing <span class="mcode">gui1</span> in the command window.
The figure window on the left will appear. As we mentioned above, the uitable and all seven uicontrols are on top
of each other near the lower left corner, so we only see the last one.
Likewise all three pseudo sliders are also on top of each other in the middle of the figure.
Now its time to fix this problem. Type <span class="mcode">plt&nbsp;move</span> in the command window
to enable the mouse driven repositioning mode.
<br clear=left>
<img src="../images/gui1Place2.png" width=238 height=207 hspace=10 vspace=10 align="left"><br>
The graphical objects inside the current figure are grayed out to indicate that the repositioning
mode is active. Now we can:
<br><br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; Left click, hold, and drag to move an object.<br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; Right click, hold and drag to resizes an object.<br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; Double click to open an object's property inspector window.
<br><br>
At the stage shown here we at least have moved and resized all the objects so we can see all the individual items,
none of them overlap, and they are at least close to the positions we outlined in our sketch.
<br clear=left><br>
I notice that the frame is too bright since I intended it to be a subtle grouping. One way to adjust this is
by typing commands into the command window. After clicking on an object (in repositioning mode) a variable
called "hhh" is added to the base workspace containing the object's handle. So now I can experiment with colors
or other properties by typing commands such as:
<br><br>
<nobr><span class="mcode">set(hhh,'backgr',[1 1 2]/6,'foregr',[1 1 1]/2);</span>.</nobr>
<br><br>
Once I get the look I want I can copy and paste the command from the command window into the program (right before
the line that saves the handles to the figure userdata):
<br><br>
<nobr><span class="mcode">set(h(1),'backgr',[1 1 2]/6,'foregr',[1 1 1]/2);</span>.</nobr>
<br><br>
Note that I changed the "hhh" to h(1) before inserting the line into the program.
A second method for doing this (instead of typing the commands in the command window) is to double click on the
object which will bring up the property inspector for that object. Then as you change the property values
in the inspector you will immediately see the effect on the GUI. (The second method is certainly easier if you
don't know the exact property names for the objects you are working with.)
<br>
<img src="../images/gui1Place3.png" width=238 height=207 hspace=10 vspace=10 align="left"><br>
With a little more rearranging we finally get the look we are aiming for as shown here.
Note that the controls are still grayed out since the repositioning mode is still active.
One thing that you will notice while repositioning objects is that moving the frame also
moves all the objects inside the frame. Unless you have a very old version of Matlab you may
also use a uitable to allow this grouping effect. The main advantage of the uitable is that
you can optionally specify a label for the grouping that will appear along the top edge.
(The second example demonstrates this.)
<br><br>
Before exiting the program or canceling the repositioning mode click on each of the graphical
objects once in the order that you created them in the program (left to right and top to bottom in the GUI).
As you are clicking each item, plt will be displaying the positions of the objects in the command window.
When you are done the command window will contain something similar to this:
<br clear=left><br>
<nobr><span class="mcode3">uic: 207 &nbsp;.540 .500 .440 .280; &nbsp;% frame1</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">uic: 206 &nbsp;.680 .710 .170 .050; &nbsp;% choice A</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">uic: 205 &nbsp;.570 .610 .380 .060; &nbsp;% slider</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">uic: 204 &nbsp;.570 .520 .170 .060; &nbsp;% button1</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">uic: 203 &nbsp;.780 .520 .170 .060; &nbsp;% check001</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">uic: 202 &nbsp;.020 .050 .480 .400; &nbsp;% 1.79e9 &nbsp; 8.4e-6 &nbsp; 2.5e12</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">uic: 201 &nbsp;.540 .050 .440 .400; &nbsp;% 1.79e9 &nbsp; 8.4e-6 &nbsp; 2.5e12</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">sli: 401 &nbsp;.020 .920 .300; &nbsp; &nbsp; &nbsp; % PseudoSlider 1</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">sli: 406 &nbsp;.350 .920 .300; &nbsp; &nbsp; &nbsp; % PseudoSlider 2</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">sli: 411 &nbsp;.680 .920 .300; &nbsp; &nbsp; &nbsp; % PseudoSlider 3</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">uit: 208 &nbsp;.020 .500 .480 .280; &nbsp;% uitable</span>&nbsp;</nobr>
<br><br>
The first column is a three letter identifier for the object type. The native Matlab types - uicontrol,
uitable, uipanel, axis, and text are identified as uic, uit, uip, axi, txt respectively and plt's pseudo objects
are identified as sli, edi, pop, and xy. (xy refers to elements created by the cursor and plot pseudo objects.)
The next column is a unique integer associated with the object. We won't need that now, but example 2 will show
how that is used. The next four columns (or three columns for the pseudo sliders) specify the size and position
of each object in normalized units. At the end of the line, the object type or string property of the object is
included as a comment to make it clear which object the line refers to.<br>
<img src="../images/gui1Edit1.png" width=700 height=340 hspace=10 vspace=10 align="left"><br>
Now we are going to make the hard work we did to reposition the controls permanent. First cut and paste
the 11 lines of coordinates from the command window (shown above in blue) directly into the gui1.m
source code.
<br clear=left><br>
<img src="../images/gui1Edit2.png" hspace=10 vspace=10 align="left"><br>
Then we fix up the 11 imported lines by deleting everything except the coordinates and comments,
and adding brackets as appropriate. I've also made slight changes to the comments for clarity.
I find it handy to turn on my editor's keystroke recording while fixing up the first line. Then
I can replay this record to fix up the remaining ten lines by hitting the "play macro" button ten times.
Most editors have this feature ... but even if you do each line manually, it's not a big deal.
<br clear=left><br>
<img src="../images/gui1Edit3.png" hspace=10 vspace=10 align="left"><br>
Finally, in this line where we are setting the position of all seven uicontrols to the same
value ... we have to change that (as shown here) so that the last seven entries of the position array
are used in sequence.
<br clear=left><br>
<img src="../demoImages/gui1.png" width=283 height=246 hspace=10 vspace=10 align="left"><br>
Hit save on your editor, close the gui1 figure window, type "gui1" in the command window to
restart it ... and as we hoped the GUI appears just as we had organized it.
Try expanding the size of the figure window and note how all the objects grow in proportion
to the figure size. This is because we used normalized coordinates throughout. If you want to
convert this GUI to pixel coordinates, enter repositioning mode, type
<nobr><span class="mcode">set(findobj(gcf),'units','pix'),</span></nobr> and then
click on every graphics object, again in the same order as they are defined. Again, cut
and paste the coordinates (which now are integer pixels) into the program as we did before.
Also remove the two instances of <nobr><span class="mcode">'units','norm'</span></nobr>
(since pixels is the default when the units aren't specified). When you run it, the GUI will at first
look the same, but when you stretch the figure size, all the objects will stay exactly the same size
in the same position, thus creating empty space inside the figure. Generally you will stick with either
pixels or normalized coordinates, although you can mix them if it suits your purposes.
<br clear=left><br>
This concludes our example, although if this was a real GUI you would not likely be satisfied yet.
But using the methods we just demonstrated you will be able to iterate until you are satisfied
with the control types and positions.
<br clear=left>
<h2>A second example</h2>
Now that we have covered most of the basic concepts and techniques, its time to explore the true power
of plt by reviewing the design of a real GUI in one of the application areas that Matlab was designed for.
The application I have chosen is the display and analysis of the classical analog filters. Granted this
is not a particularly novel idea as it probably has been done before in Matlab and other languages,
but nonetheless it serves various educational and practical needs and there is always room to apply
our own slant to the project. I'll start out with a relatively modest set of goals:
<ul>
<li>Display the magnitude frequency response for the five "classical" analog filters (Butterworth,
    Bessel, Chebyshev type 1 & 2, and Elliptic). The user should be able to easily select which
    of these filters to display, as well as allowing all of them (or any subset) to be plotted
    at the same time.
<li>Interactive selection of the filter order and type (lowpass, highpass, bandpass, stopband).
<li>Interactive selection of the number of decades to plot as well as the frequency resolution.
<li>Both numerical entry and slider control of cutoff frequencies and pass/stop band ripple.
<li>Cursors should be provided which allow for the easy readout of the frequency response at any
    point as well as delta readouts to verify stop band and pass band ripples. Peak finding
	should be provided as well as the ability to annotate the plot with text and markers
    to document features of interest.
</ul>
<img src="../images/gui2Sketch.png" hspace=10 vspace=10 align="left"><br>
As is my habit, I start with a sketch to clarify my thoughts. I decide to use an array of four
pseudo sliders along the top to control the continuously adjustable parameters (edge frequencies & ripple)
The four remaining filter and display parameters are grouped to the left of the sliders inside a
uipanel unimaginatively labeled "Parameters". The Trace IDs to the left of that will be named
after the classical filter types and be used to select which filters to display. The plot and
the cursor controls and readouts along the bottom edge are the standard ones created by the plt
pseudo object.
<br clear=left><br>
Ok ... it's time to start writing code. First I have to come up with some first guess for the object positions,
and then I define the choices for filter type and number of points to display:
<br><br>
<nobr><span class="mcode">function gui2()</span></nobr><br>
<nobr><span class="mcode"> &nbsp; p = {[.4 .3 .5 .5]; &nbsp;</span><span class="cmt">% plot position </span></nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp;[.2 .5 .1 .2]; &nbsp;</span><span class="cmt">% uipanel position: Parameters </span></nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp;[.2 .5 .1 .2]; &nbsp;</span><span class="cmt">% edit position: filter order </span></nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp;[.2 .5 .1 .2]; &nbsp;</span><span class="cmt">% popup position: filter type </span></nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp;[.2 .5 .1 .2]; &nbsp;</span><span class="cmt">% popup position: # of decades </span></nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp;[.2 .5 .1 .2]; &nbsp;</span><span class="cmt">% popup; position: # of points </span></nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp;[.2 .2 &nbsp; &nbsp; &nbsp;]; &nbsp;</span><span class="cmt">% slider position: Passband ripple </span></nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp;[.2 .2 &nbsp; &nbsp; &nbsp;]; &nbsp;</span><span class="cmt">% slider position: Stopband ripple </span></nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp;[.2 .2 &nbsp; &nbsp; &nbsp;]; &nbsp;</span><span class="cmt">% slider position: Cutoff frequency </span></nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp;[.2 .2 &nbsp; &nbsp; &nbsp;]}; </span>
<span class="cmt">% slider &nbsp;position: frequency 2 </span></nobr><br>
<nobr><span class="mcode"> &nbsp; typ = {'low pass' 'high pass' 'band pass' 'stop band'}; &nbsp;pts = 100*[1 2 4 8 16];</span></nobr><font size="+1">&nbsp;<br></font>
<br>
So how good are my guesses? Look at the first screen shot below to find out.
Clearly not so good. The plot is way too small compared to my sketch.
All the pseudo sliders are on top of each other ... and they are near the bottom
instead of near the top as shown in the sketch. Plus all the pseudo popups and edit
objects are also on top of each other. But as you will see, this will not be a
problem at all. In fact, it would be a waste of time to spend more than a minute coming
up with the initial guess. Ok, now it is time to create the plotting pseudo object
(figure, axis, cursor, grid, traces, etc):
<br><br>
<nobr><span class="mcode"> &nbsp; S.tr = plt('FigName','gui2',0,zeros(1,5),'Options','LogX','Ylim',[-80 10],... </span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'TraceID',{'butter' 'bessel' 'cheby1' 'cheby2' 'elliptic'},... </span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 'xy',p{1},'LabelX','radians/sec','LabelY','dB'); </span>&nbsp;</nobr>
<br><br>
The <span class="mcode">'xy'</span> parameter is used to position the plot within the figure window
(although you will soon learn that this parameter can do far more than that). The data to be plotted
for all 5 traces is defined in the plt call (as it must), but notice that each trace just contains
the single point (0,0). When calling plt from the command line, you almost always include the actual
plot data in the argument list, however in a GUI more often than not the data supplied is just a
place holder. The real data is loaded later (in the callback in this example) by using the trace
handles returned by plt. Note that we save these handles in <span class="mcode">S.tr</span> (a 1x5 array).
S is the structure where we will store the handles of all the objects we define in the GUI.
The remaining plt parameters should be reasonably self explanatory. Next we create the uipanel and the
four pseudo objects that we will put inside it:
<br><br>
<nobr><span class="mcode"> &nbsp; uipanel('units','norm','title','Parameters','backgr',get(gcf,'color'),...</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;'pos',p{2} ,'high',[.4 .4 .4],'foregr',[.4 .4 .4]);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; S.n &nbsp; = plt('edit', &nbsp;p{3} ,[6 1 25],'callbk',@clb,'label',{'Order:' .05});</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; S.typ = plt('pop', &nbsp; p{4} ,typ,'callbk',@clb,'swap');</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; S.dec = plt('pop', &nbsp; p{5} ,1:5,'callbk',@clb,'index',3,'label','Decades:');</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; S.pts = plt('pop', &nbsp; p{6} ,pts,'callbk',@clb,'index',2,'label','Points:');</span>&nbsp;</nobr>
<br><br>
For the uipanel, I set the background color to be the same as the figure color to give it a
transparent look. For both the border outline and the text label of the uipanel I used light
grey (rgb = .4 .4 .4). The uipanel wasn't invented yet for Matlab 6, so there is an alternate
version of gui2.m called gui2v6.m in the demo folder where this uipanel was replaced by an
axis. Note that the tag property of the axis was set to 'frame'. This is to tell plt that
moving the axis in repositioning mode should also move all the objects inside it (even
objects not children of the axis).
<br><br>
The [6 1 25] parameter of the pseudo edit object means that its initial
value will be six with min/max limits of 1 and 25. The string 'Order' is used as a label for
the edit object, and the ".05" tells it how much space to allocate for the label (in normalized
coordinates). The parameters for the three pseudo popup objects are probably more obvious,
but if not, consult the <a href="Pseudo%20objects.htm">Pseudo objects</a> page.
Next we create the pseudo sliders:
<br><br>
<nobr><span class="mcode"> &nbsp; S.Rp &nbsp;= plt('slider',p{7} ,[ 2 &nbsp;.01 &nbsp; 9],'Passband ripple', @clb);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; S.Rs &nbsp;= plt('slider',p{8} ,[ 40 &nbsp;10 120],'Stopband ripple', @clb);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; S.Wn &nbsp;= plt('slider',p{9} ,[.02 .001 &nbsp;1],'Cutoff frequency',@clb,5,'%4.3f 6 2');</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; S.Wm &nbsp;= plt('slider',p{10},[.2 &nbsp;.001 &nbsp;1],'frequency 2', &nbsp; &nbsp; @clb,5,'%4.3f 6 2');</span>&nbsp;</nobr>
<br><br>
The [2 .01 9] on the first slider has the same meaning as the similar pseudo edit parameter mentioned
above - i.e. 2 is the initial value with min/max limits of .01 and 9. The @clb specifies the callback function.
(Note that same callback function is used for all the controls.) The "5" after the callback function indicates
that the slider will move logarithmically (so for example the slider will move the same number of pixels going from
.01 to .1 as it does when changing from .1 to 1. The final parameter <span class="mcode">'%4.3f 6 2'</span> is
shorthand for <span class="mcode">'%4.3f %6v %2v'</span> and specifies the display format for the min value,
current value, and max value respectively. Now we have just a few more lines left to complete the gui2.m function:
<br><br>
<nobr><span class="mcode"> &nbsp; S.cid = get(gca,'user');</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; set(gcf,'user',S);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; clb;</span>&nbsp;</nobr><br>
<nobr><span class="mcode">% end function gui2</span>&nbsp;</nobr>
<br><br>
The first line saves the cursor ID in the handle structure. The next line saves the handle structure
in the figure user data where the callback function can easily retrieve it.
The last line calls the callback function to initialize the display to correspond with the initial
values of the controls. We're finished writing the main line function, after just 18 lines of code, plus
10 more lines for our initial guess for the control positions. But now the real work begins - the
callback function that makes the GUI come alive:
<br><br>
<nobr><span class="mcode">function clb() % callback function for all objects;</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; S = get(gcf,'user');&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>
<span class="cmt">% get handle structure</span></nobr><br>
<nobr><span class="mcode"> &nbsp; ty = plt('pop',S.typ,'get'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>
<span class="cmt">% get filter type index</span></nobr><br>
<nobr><span class="mcode"> &nbsp; t = {'low' 'high' 'bandpass' 'stop'}; &nbsp;t = t{ty}; &nbsp; &nbsp;</span>
<span class="cmt">% get filter type name</span></nobr><br>
<nobr><span class="mcode"> &nbsp; N &nbsp;= plt('edit',S.n,'get'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>
<span class="cmt">% get filter order</span></nobr><br>
<nobr><span class="mcode"> &nbsp; dec = plt('pop',S.dec,'get'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>
<span class="cmt">% get number of decades to plot</span></nobr><br>
<nobr><span class="mcode"> &nbsp; pts = str2num(get(S.pts,'string')); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>
<span class="cmt">% get # of points to plot</span></nobr><br>
<nobr><span class="mcode"> &nbsp; X &nbsp;= logspace(-dec,0,pts); &nbsp;W = X*1i; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>
<span class="cmt">% X-axis data (radians/sec)</span></nobr>
<br><br>
First we pick up the filter parameters that are inside the uipanel (filter type, order, number of points,
number of decades). You might wonder why I seem to repeat myself by defining the filter types again since it
would seem more logical to simply get the filter type with <span class="mcode">get(S.typ,'string')</span>.
That command would retrieve one of the following strings:
<nobr>{'low pass' 'high pass' 'band pass' 'stop band'},</nobr>
but the strings accepted by the Matlab filter functions are slightly different:
<nobr>{'low' 'high' 'bandpass' 'stop'}.</nobr>
It would have been much easier just to use the strings that Matlab requires for the popup control, but I was
too picky about the look of the popup control to use those somewhat inconsistent strings.
Finally the logspace command generates the requested number of points
logarithmically spaced between .001 and 1 (for the 3 decades example). W is this same vector on the
imaginary axis, which is used with polyval to compute the frequency response function.
<br><br>
<nobr><span class="mcode"> &nbsp; Wn = plt('slider',S.Wn,'get'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>
<span class="cmt">% get filter freq</span></nobr><br>
<nobr><span class="mcode"> &nbsp; Rp = plt('slider',S.Rp,'get'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>
<span class="cmt">% get passband ripple</span></nobr><br>
<nobr><span class="mcode"> &nbsp; Rs = plt('slider',S.Rs,'get'); Rs2 = max(Rp+.1,Rs); &nbsp;</span>
<span class="cmt">% get stopband ripple (must be > passband)</span></nobr><br>
<nobr><span class="mcode"> &nbsp; if ty>2 Wn = [Wn plt('slider',S.Wm,'get')]; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>
<span class="cmt">% get frequency 2</span></nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; plt('slider',S.Wm,'set','visON'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>
<span class="cmt">% make frequency 2 slider visible</span></nobr><br>
<nobr><span class="mcode"> &nbsp; else &nbsp; &nbsp;plt('slider',S.Wm,'set','visOFF'); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;</span>
<span class="cmt">% make frequency 2 slider invisible</span></nobr><br>
<nobr><span class="mcode"> &nbsp; end;</span>&nbsp;</nobr>
<br><br>
Next we pick up the filter parameters from the four pseudo sliders. Note that for the last two filter types (bandpass and stopband)
we need the second frequency slider ("frequency 2") and so this slider is only visible when one of those filter types is selected.
<br><br>
<nobr><span class="mcode"> &nbsp; [B,A] = butter(N,Wn,t,'s'); &nbsp; &nbsp; &nbsp; &nbsp;H{1} = polyval(B,W)./polyval(A,W);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; [B,A] = besself(N,Wn(1)); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;H{2} = polyval(B,W)./polyval(A,W);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; [B,A] = cheby1(N,Rp,Wn,t,'s'); &nbsp; &nbsp; H{3} = polyval(B,W)./polyval(A,W);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; [B,A] = cheby2(N,Rs,Wn,t,'s'); &nbsp; &nbsp; H{4} = polyval(B,W)./polyval(A,W);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; [B,A] = ellip(N,Rp,Rs2,Wn,t,'s'); &nbsp;H{5} = polyval(B,W)./polyval(A,W);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; if ty~=1 H{2}=H{2}+NaN; end; &nbsp; &nbsp; &nbsp; &nbsp;</span>
<span class="cmt">% bessel filter only applicable for low pass</span></nobr>
<br><br>
Then we use the Matlab classical filter functions to compute the numerator and denominator s-plane
polynomials (B,A) and compute the frequency response using polyval. Although it would have
been slightly shorter to use freqs() instead of polyval(), I didn't do that since freqs is part
of a toolbox that some users will not have. If a filter type other than low pass is selected, the
last line changes the Bessel transfer function to "NaN" so that the trace will not appear on
the plot. (The Bessel filter is only defined for low pass.)
<br><br>
<nobr><span class="mcode"> &nbsp; for k=1:5 set(S.tr(k),'x',X,'y',20*log10(abs(H{k}))); end; &nbsp;</span>
<span class="cmt">% set trace data</span></nobr><br>
<nobr><span class="mcode"> &nbsp; plt('cursor',S.cid,'set','xlim',X([1 end])); &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;</span>
<span class="cmt">% set Xaxis limits</span></nobr><br>
<nobr><span class="mcode">% end function clb</span>&nbsp;</nobr>
<br><br>
Then we use the absolute value function to compute the magnitude of the frequency response, and convert
to dB (20*log10) before placing the result in the y-axis property of the 5 traces. Finally to set the
x-axis limits in case they have changed (which happens when the callback is in response to the "number of
decades" control).
<img src="../images/gui2Place1.png" width=427 height=336 hspace=10 vspace=10 align="left">
<br><br>
Finally we are done with the initial coding and we can try it out. Typing "gui2" to start the program
brings up this figure. Although all the controls are there as promised, they are not anywhere close
to being in the right place, but it will take only a few minutes to fix this. Begin by entering
"repositioning mode" by right clicking on the delta button (or if you prefer, by typing
<span class="mcode">plt&nbsp;move</span>.) Then as I described in the previous example, use a left
click and drag to move the objects around and a right click and drag to resize them.
<br clear=left><br>
<img src="../images/gui2Place2.png" width=427 height=336 hspace=10 vspace=10 align="left"><br>
I still don't have the final positioning, but it's close. The uipanel contains the controls it should
and the other objects are also at least in the vicinity of where they should be. Note that once objects
are placed inside the uipanel, moving the uipanel will also move all the objects inside it.
After a few more tweaks, we will have at least our first cut positioning. Before closing this figure
it is important to remember to left click once on every object, in the order that they were created
in our program. As we are doing this, the text below will appear in the command window:
<br clear=left><br>
<nobr><span class="mcode3">&nbsp;xy: &nbsp; 1 &nbsp;.130 .105 .840 .760; &nbsp;% axes</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">uip: 213 &nbsp;.100 .885 .240 .110; &nbsp;% uipanel</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">edi: 211 &nbsp;.165 .935 .040 .030; &nbsp;% &nbsp; 6</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">pop: 102 &nbsp;.110 .710 .100 .200; &nbsp;% band pass</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">pop: 103 &nbsp;.310 .750 .020 .200; &nbsp;% 3</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">pop: 104 &nbsp;.287 .710 .054 .200; &nbsp;% 200</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">sli: 401 &nbsp;.350 .946 .150 &nbsp; &nbsp; ; &nbsp;% Passband ripple</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">sli: 406 &nbsp;.510 .946 .150 &nbsp; &nbsp; ; &nbsp;% Stopband ripple</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">sli: 411 &nbsp;.670 .946 .150 &nbsp; &nbsp; ; &nbsp;% Cutoff frequency</span>&nbsp;</nobr><br>
<nobr><span class="mcode3">sli: 416 &nbsp;.830 .946 .150 &nbsp; &nbsp; ; &nbsp;% frequency 2</span>&nbsp;</nobr><br>

<img src="../images/gui2Edit1.png" width=575 height=261 hspace=10 vspace=10 align="left"><br>
Then as before, we copy and paste those lines into the source code as shown here.
<br clear=left><br>

<img src="../images/gui2Edit2.png" width=357 height=268 hspace=10 vspace=10 align="left"><br>
We could fix up the brackets and comments line by line as we did in the previous example, however since my
editor has a column select mode (as pretty much every programmers editor does) I find it easier to block
delete the old coordinates (our rough first guess) and then do a block move (as shown by the red arrow)
the new coordinates into the blank array.
<br><br>
We're done with the repositioning step, so we hit save in our editor, restart the application and we
should see a figure similar to the one below.
<br clear=left><br>
<img src="../images/gui2s.png" width=427 height=336 hspace=10 vspace=10 align="right"><br>
Now we can play with all the controls and make sure everything is behaving as we
imagined. Not bad considering we've written a non-trivial GUI applications involving non-trivial
filter computations by writing only 51 lines of code. (Fewer if you don't count the automatically
generated table of numbers that specify the object positions.) It's the power of the pseudo objects
that allows the program to be written so quickly and concisely. 
<br><br>
Of course what nearly always happens the first time you get to experiment with your GUI is that
you will have some new ideas:
<ul style="overflow:hidden">
    <li>Perhaps this isn't the most convenient set of controls. Would it be more useful to have
        fewer controls, more controls, ... or just different controls?
    <li>Even if the controls seem appropriate, perhaps it would be more esthetically pleasing to rearrange
        and resize them?
    <li>Do we have features that we don't really need? Or can we add useful features without making
        the GUI too complicated?
    <li>Can we rearrange or refactor the code to make it easier to understand and adapt?
</ul>
<br clear=left>
Indeed when I got to this stage of testing the application I did have a few enhancement ideas:
<ol><li>I was curious (mostly for the elliptic filter) how the width of the transition band
        (the space between the passband and the stopband) varied as the filter order changed
        as well as the four slider parameters. Could I define such a measure, figure out how to
        compute it and find a place on the GUI to display it?
    <li>My second idea was to allow the user to control at least some aspect of the color choices used
        in the application. Actually I don't think such a simple application like this really needs
        this flexibility, but my ulterior motive was to showcase the ColorPick pseudo object and how
        easy it is to add to your GUI and how easy it is to select the color you find most pleasing
        for any display element.
    <li>What does the phase response of these filters look like? Could I add a display of the phase
        response without cluttering up the plot or obscuring the magnitude response (which is still
        the primary interest).
    <li>It would be nice if whenever we made a change to the figure size/position or the color
        selection, that these changes would be recorded so that the application looks the same
        the next time it is restarted. While we are at it, we might as well remember the state
        of the eight filter parameters (shown above the plot) so that on start up, the figure
        looks identical to the way it was when it was shut down.
</ol>
These enhancements turned out to be fairly easy to implement.
You can look at the final code which includes these enhancements (gui2.m in the plt\demo folder)
or read on to find out more about the process.
<h3>1.) Adding a multi-line text string <i>(elliptic transition ratio)</i></h3>
<img src="../images/etr.png" hspace="10" vspace="10" align="left"><br>
For a low pass filter, I characterized the transition width in terms of the ratio of these two frequencies:<br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; The frequency where the stop band spec is first achieved<br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; divided by the last frequency where the passband spec is still achieved<br>
For a high pass filter, the ratio is:<br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; The frequency where the pass band spec is first achieved<br>
&nbsp; &nbsp; &nbsp; <font size="+1"><b>&bull;</b></font> &nbsp; divided by the last frequency where the stopband spec is still achieved
<br clear=left><br>
I added an 11th line to the position array at the beginning of the program, to define the location
for the new text object. Initially it was just a wild guess as usual which was refined using the
repositioning mode:
<br><br>
<nobr><span class="mcode"> &nbsp; [-.09 .650 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;]; </span>
<span class="cmt">% text position: elliptic transition ratio</span></nobr>
<br clear=left><br>
The text object was created with this line (added after the slider definitions):
<br><br>
<nobr><span class="mcode"> &nbsp; S.etr = text(0,0,'','pos',p{11},'units','norm','horiz','center','color',[.2 .6 1]);</span>&nbsp;</nobr>
<br><br>
Note that the string to display was set to null, because the actual string to display will be set in the callback function as follows:
<br><br>
<nobr><span class="mcode"> &nbsp; h = find(get(S.tr(5),'y') < -Rs2);&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span>
<span class="cmt">% find indices where the stopband spec is satisfied</span></nobr><br>
<nobr><span class="mcode"> &nbsp; if &nbsp; &nbsp; isempty(h) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;h = 0;
&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; </span><span class="cmt">% stopband specification not achieved</span></nobr><br>
<nobr><span class="mcode"> &nbsp; elseif (ty-2)*(ty-3) &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; h = X(h(1))/Wn(1); </span>
<span class="cmt">% computation for lowpass & stopband filters</span></nobr><br>
<nobr><span class="mcode"> &nbsp; else &nbsp; &nbsp;h = find(diff([h inf])>1); &nbsp; h = Wn(1)/X(h(1)); </span>
<span class="cmt">% computation for highpass & passband filters</span></nobr><br>
<nobr><span class="mcode"> &nbsp; end;</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; set(S.etr,'string',prin('Elliptic ~, transition ~, ratio: ~, %5v',h));</span>&nbsp;</nobr>
<br><br>
This last line takes advantage of prin's cell array delimiter feature to create the multi-line string used to display the elliptic transition ratio in the small space available on the left side of the plot. To learn more
about <span class="mcode">prin</span> and the <span class="mcode">%v</span> format used here,
check out the <a href="Auxiliary%20functions.htm">Auxiliary functions</a>.

<h3>2.) Selecting colors</h3>
<img src="../images/sliderColor.png" hspace="10" vspace="10" align="left"><br>
This was the simplest of the three enhancements requiring just the three extra lines shown below.
I decided to enable color adjustment of just the pseudo sliders (the most prominent controls),
although it would be easy to extend this to other graphic elements. In this figure I have changed
the background color of the sliders from its default gray to orange. I encourage you to play around
with this ColorPick figure. (Just right click on any of gui2's pseudo sliders to bring up ColorPick.)
If you have ever dealt with the frustrations of assigning screen colors, I think you will be
pleasantly surprised about how easy it can be. Also you can read about the ColorPick details near
the bottom of this page: <a href="Pseudo%20objects.htm">Pseudo objects</a>
<br><br>The first line (below) gets puts the handles of all the objects associated with pseudo sliders
into "h". Then the 5th element of each slider is removed, since that is the edit box portion which
generally is set to a contrasting color. The second line assigns the ColorPick object as the buttondown
function (the action associated with <b>right</b> clicking on the pseudo slider). The third line is
necessary to tell ColorPick which property of these objects should be adjusted when a new color is
chosen (the background color in this example).
<br clear=left><br>
<nobr><span class="mcode"> &nbsp; h = getappdata(gcf,'sli'); &nbsp;h(5:5:end) = [];</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; set(h,'buttondown','plt ColorPick;');</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; for k = 1:length(h) setappdata(h(k),'m',{'backgr' h}); end;</span>&nbsp;</nobr>

<h3>3.) Linking traces <i>(adding the phase display)</i></h3>

To add the phase display, the most important change is in the callback function. Before we
set trace data for 5 traces, but now we must set trace data for 10 traces (the first five
for magnitude and the last five for phase):
<br><br>
<nobr><span class="mcode"> &nbsp; for k=1:5 &nbsp; </span><span class="cmt">% set trace data</span></nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; set(S.tr([k k+5]),'x',X,{'y'},{20*log10(abs(H{k})); angle(H{k})*180/pi});</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; end;</span>&nbsp;</nobr>
<br><br>
Then we just need to increase the data array defining the traces in the plt call
from 5 to 10, specify that the last 5 traces should be on the right hand axis ... and we would be done.
However then we would need 10 TraceIDs up there as well. I didn't want that because then to enable or
disable the trace for the cheby1 filter (for example), I would have to click on two TraceID tags.
Not so convenient. Also by default, ten different colors would be chosen for the ten traces. This would
make it more difficult to tell which phase trace was associated with which magnitude trace. Both these
problems are fixable of course:
<br><br>
<nobr><span class="mcode"> &nbsp; c = [0 1 0; 1 0 1; 0 1 1; 1 0 0; .2 .6 1];</span>
<span class="cmt">% trace colors</span></nobr><br>
<nobr><span class="mcode"> &nbsp; lbl = {'dB' [blanks(70) 'Phase \circ']}; &nbsp;</span>
<span class="cmt">% y-axis labels: {left, right}</span></nobr>
<br><br>
The first line above defines the trace colors that also happen to be the default colors
normally used for the first five traces. Only we are going to use them below for both
the first five traces as well as for the last five traces. The next line defines the y-axis
labels for both the left axis (magnitude response in dB) and for the right axis (phase
response in degrees). Note the Tex command "\circ" in the right axis which inserts a
small circle (the degree symbol) into the label. The 70 blanks that are inserted in front
of the right hand label is used to push the label up towards the top of the display where
the phase information will be plotted. And finally we have to fix up the main plt call:
<br><br>
<nobr><span class="mcode"> &nbsp; S.tr = plt('FigName','gui2',0,zeros(1,10),'Right',6:10,'Options','LogX',...</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
'DualCur',-5,'TraceID',{'butter' 'bessel', 'cheby1' &nbsp;'cheby2' 'elliptic'},...</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
'Ylim',{[-90 60] [-1000 200]},'LabelX','radians/sec','LabelY',lbl,...</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
'TIDcback','t=plt("show"); t=t(find(t<6)); plt("show",[t t+5]);',...</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
'xy',p{1},'TraceC',[c;c],'+Ytick',-140:20:0,'-Ytick',[-180 0 180]);</span>&nbsp;</nobr>
<br><br>
Some of the parameter changes in the plt call were already mentioned, but some others merit mention:<br>
<ul><li>The 'DualCur' parameter with minus five as an argument tells plt that the second trace
        number that should be cursored is offset from the first one by five. This means for example,
        if you click on trace 2, not only will a cursor appear on trace 2, but trace 7 will also have
        a cursor. (And each cursor will have a separate readout edit box as well.)
    <li>The 'Ylim' parameter now includes two sets of y limits. As with the 'LabelY' command, the
        first entry is for the left axis and the second is for the right axis. The limits have been
        chosen to position the magnitude response on the lower portion of the graph and the phase
        response on the upper portion.
    <li>The '+Ytick' and '-Ytick' parameters specify the tick marks to be used on the left and right
        hand axis (respectively). We don't technically need these parameters, but it looks better to
        include tick marks only in the area where the data can be located.
    <li>The addition of the 'TIDcback' parameter is perhaps the most interesting. This defines a
        callback function that is executed every time you click on any one of the TraceID text strings.
        Here, the plt('show') function (see "Single argument actions" near the end of this
        <a href="Calling%20sequence%20and%20line%20styles.htm">page</a>) is used to enable only those
        phase traces that correspond to magnitude traces that are also enabled.
</ul>
<h3>4.) Saving/restoring the GUI state using a configuration file</h3>
Before the call to plt, let's choose a file name and path for saving the configuration data:
<nobr><span class="mcode"> &nbsp; S.cfg = [which(mfilename) 'at'];</span>&nbsp;</nobr>
<br><br>
Next let's add a new function, called cfg which saves the current configuration to the file:
<br><br>
<nobr><span class="mcode"> &nbsp; function cfg()</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp;
S = get(gcf,'user');  sli = findobj(gcf,'style','slider');</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp;
cf = { plt('edit',S.n,'get'); &nbsp;&nbsp; plt('pop',S.typ,'get');</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
plt('pop',S.dec,'get'); &nbsp; plt('pop',S.pts,'get');</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
plt('slider',S.Rp,'get');  plt('slider',S.Rs,'get');</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
plt('slider',S.Wn,'get');  plt('slider',S.Wm,'get');</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
get(sli(1),'background');  get(gcf,'pos') &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; };</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp;
save(S.cfg,'cf');</span>&nbsp;</nobr>
<br><br>
Then right before we initialize the plot, we load the configuration file if it exists
and set the GUI elements to agree with the data in the file:
<br><br>
<nobr><span class="mcode"> &nbsp; &nbsp; if exist(S.cfg) load(S.cfg);</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
plt('edit',S.n,'value', cf{1});  plt('pop',S.typ,'index',cf{2});</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
plt('pop',S.pts,'index',cf{3});  plt('pop',S.dec,'index',cf{4});</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
plt('slider',S.Rp,'set',cf{5});  plt('slider',S.Rs,'set',cf{6});</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
plt('slider',S.Wn,'set',cf{7});  plt('slider',S.Wm,'set',cf{8});</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
set(h,'background',     cf{9});  set(gcf,'position',     cf{10});</span>&nbsp;</nobr><br>
<nobr><span class="mcode"> &nbsp; &nbsp; end;</span>&nbsp;</nobr>
<br><br>
And finally we add this parameter to the <span class="mcode">plt</span> call:
<br><br>
<nobr><span class="mcode"> &nbsp; &nbsp; 'closeReq',@cfg</span>&nbsp;</nobr>
<br><br>
This instructs plt to call the function that saves the configuration data when the user closes
the figure window to exit the application.
<br><br>
This concludes our discussion of the gui2 example. Although it might seem like coding this example was
a lot of work, only about 85 lines of code were needed to implement a fairly complex set of display and
computational requirements. GUI programming is notorious for its complexity, and I think if you tried
to implement a this application in other programming languages you would be looking at a far bigger
effort with source code running into the many hundreds of lines. I would like to be able to report how
long the program would be in Matlab using GUIDE (without using plt), so I would be thrilled if one of
the guide experts out there would take up this challenge by implementing the original five goals of gui2
as well as the four enhancements. If you manage to do this, I would gladly include your GUI (with credit
of course) to contrast the Guide programming style with the one I presented here.
<br><br>
To further your education of GUI programming with plt, I especially recommend reviewing the
<span class="mcode">pltsq.m</span> application if you are interested in moving plots (i.e. real-time updating).
Also the<span class="mcode"> curves.m</span>, <span class="mcode">editz.m</span>, and
<span class="mcode">winplt.m </span>applications are worth reviewing since they each have
a fairly rich GUI design with lots of opportunities for using various plt features in interesting ways.

<h2>SnapTo resolution</h2>
You may have noticed that in repositioning mode, the objects when dragged don't move or resize smoothly,
but rather move in steps of a fixed size. This makes it easier to align related objects and generally
gives a more pleasing result. The default grid size is 100 by 100 which means that there are 100 useable
positions inside the figure in both the x and y directions. This also means that if you are using normalized
coordinates the third decimal place for all position vector elements will be zero.
<br><br>
There are three ways to bring up the SnapTo figure shown below:
<ol><li>Type <span class="mcode">plt move res</span> in the command window. (This is the only method if you are not using a plot pseudo object).
    <li>First left click on the delta button, followed by a right click on the same button.
    <li>It's easy to forget the sequence for method two, so you can also go to the plt menu in the menu bar. There you will see the option
	    <i>"Reposition grid size"</i> which will bring up the SnapTo figure.
</ol>

<img src="../images/SnapTo.png" hspace="10" vspace="10" align="left"><br>

The default resolution is usually enough, but if you want finer control, move one or both of these sliders to the right edge (i.e. 200).
This is nearly always enough, although if you like you can type in a number bigger than 200 into either edit box.
Or you can move the slider all the way to the left (i.e. zero) which disables the snap-to feature altogether.

</body>

</html>